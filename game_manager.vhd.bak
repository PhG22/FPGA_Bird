LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ENTITY game_manager IS
    PORT (
        i_clk         : IN  STD_LOGIC; -- Clock principal (25 MHz)
        i_reset       : IN  STD_LOGIC; -- Reset (ativo-alto)
        
        -- Posições atuais dos elementos
        i_bird_y    : IN  STD_LOGIC_VECTOR(9 DOWNTO 0);
        i_pipe_x    : IN  STD_LOGIC_VECTOR(9 DOWNTO 0);
        i_pipe_gap_y : IN  STD_LOGIC_VECTOR(9 DOWNTO 0);
        
        -- Saída de controle
        o_game_enable : OUT STD_LOGIC -- '1' = Jogando, '0' = Game Over
    );
END game_manager;

ARCHITECTURE rtl OF game_manager IS

    -- --- Constantes de Geometria (DEVEM ser iguais às do pixel_drawer) ---
    CONSTANT C_BIRD_X_POS   : INTEGER := 100; -- Posição X fixa do pássaro
    CONSTANT C_BIRD_SIZE    : INTEGER := 20;  -- Pássaro é um quadrado 20x20
    CONSTANT C_PIPE_WIDTH   : INTEGER := 60;  -- Largura do cano
    CONSTANT C_GAP_HEIGHT   : INTEGER := 120; -- Altura total da abertura
    CONSTANT C_GROUND_Y     : INTEGER := 460; -- Onde o pássaro "bate no chão"
    
    -- Sinais para os limites das "hitboxes"
    SIGNAL bird_x_start, bird_x_end : INTEGER;
    SIGNAL bird_y_start, bird_y_end : INTEGER;
    SIGNAL pipe_x_start, pipe_x_end : INTEGER;
    SIGNAL pipe_gap_top, pipe_gap_bottom : INTEGER;

    -- Sinal de colisão combinacional
    SIGNAL s_collision_flag : STD_LOGIC;
    
    -- --- Lógica da Máquina de Estados (FSM) ---
    TYPE state_type IS (s_playing, s_game_over);
    SIGNAL current_state : state_type;

BEGIN

    -- --- 1. Lógica de "Hitbox" (Combinacional) ---
    -- Converte as entradas para inteiros para facilitar a matemática
    bird_y_start <= to_integer(unsigned(i_bird_y));
    pipe_x_start <= to_integer(unsigned(i_pipe_x));
    pipe_gap_top <= to_integer(unsigned(i_pipe_gap_y)) - (C_GAP_HEIGHT / 2);
    
    -- Calcula os limites das caixas
    bird_x_start <= C_BIRD_X_POS;
    bird_x_end   <= C_BIRD_X_POS + C_BIRD_SIZE;
    bird_y_end   <= bird_y_start + C_BIRD_SIZE;
    pipe_x_end   <= pipe_x_start + C_PIPE_WIDTH;
    pipe_gap_bottom <= pipe_gap_top + C_GAP_HEIGHT;
    
    -- Processo combinacional para verificar a colisão
    PROCESS(bird_x_start, bird_x_end, bird_y_start, bird_y_end,
            pipe_x_start, pipe_x_end, pipe_gap_top, pipe_gap_bottom)
            
        VARIABLE v_x_overlap : BOOLEAN;
        VARIABLE v_y_overlap : BOOLEAN;
        VARIABLE v_hit_pipe  : BOOLEAN;
        VARIABLE v_hit_ground: BOOLEAN;
    BEGIN
        -- 1. Há sobreposição no eixo X?
        v_x_overlap := (bird_x_end > pipe_x_start) AND (bird_x_start < pipe_x_end);
        
        -- 2. O pássaro bateu no cano de cima OU no de baixo?
        v_y_overlap := (bird_y_start < pipe_gap_top) OR (bird_y_end > pipe_gap_bottom);
        
        -- Colisão com cano só acontece se houver sobreposição em X e Y
        v_hit_pipe := v_x_overlap AND v_y_overlap;
        
        -- 3. O pássaro bateu no chão? (seu bird_logic já faz isso, mas é bom ter)
        v_hit_ground := (bird_y_end >= C_GROUND_Y);
        
        -- Seta a flag final de colisão
        IF (v_hit_pipe OR v_hit_ground) THEN
            s_collision_flag <= '1';
        ELSE
            s_collision_flag <= '0';
        END IF;
    END PROCESS;


    -- --- 2. Lógica de Estado (FSM Sequencial) ---
    PROCESS(i_clk, i_reset)
    BEGIN
        IF (i_reset = '1') THEN
            current_state <= s_playing; -- Começa jogando
            
        ELSIF (rising_edge(i_clk)) THEN
            CASE current_state IS
                WHEN s_playing =>
                    -- Se houver colisão, vá para o estado Game Over
                    IF (s_collision_flag = '1') THEN
                        current_state <= s_game_over;
                    END IF;
                    
                WHEN s_game_over =>
                    -- Fica em Game Over até o reset ser pressionado
                    NULL; -- (Não faz nada)
                    
            END CASE;
        END IF;
    END PROCESS;
    
    -- --- 3. Saída de Controle ---
    -- A saída o_game_enable é '1' APENAS se estivermos no estado s_playing
    o_game_enable <= '1' WHEN current_state = s_playing ELSE '0';

END rtl;